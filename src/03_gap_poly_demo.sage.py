

# This file was *autogenerated* from the file src/03_gap_poly_demo.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_29 = Integer(29); _sage_const_3 = Integer(3); _sage_const_100 = Integer(100); _sage_const_200 = Integer(200); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_1p0 = RealNumber('1.0')#!/usr/bin/env sage
# Purpose: finite Hecke separator P(T) with P(f)=1 and max_{g!=f}|P(g)|<1 (gap on S^⊥).
# Usage:   sage src/03_gap_poly_demo.sage <curve> [Lmax=29] [Mmax=2]
# Prints:  number of features, max|P(g)| for g!=f, and delta = 1 - max|P(g)|.
# Output:  data/gap_poly_*.json with polynomial coefficients and feature vectors
# Note:    features = {(ell,m): ell<=Lmax, m<=Mmax, ell∤N}; no cherry-picking.

import sys
from sage.all import *

# Import save utils
sys.path.append('src')
from save_utils import save_json_results

curve = sys.argv[_sage_const_1 ] if len(sys.argv) > _sage_const_1  else '37a1'
Lmax = Integer(sys.argv[_sage_const_2 ]) if len(sys.argv) > _sage_const_2  else _sage_const_29 
Mmax = Integer(sys.argv[_sage_const_3 ]) if len(sys.argv) > _sage_const_3  else _sage_const_2 

E = EllipticCurve(curve)
N = E.conductor()
C = ComplexField(_sage_const_100 )

# Newforms at level N (weight 2)
S = CuspForms(N, _sage_const_2 )
NFs = S.newforms('a')

# Identify the form f attached to E by matching first few a_l
def match_form_to_E(NFs, E, B=_sage_const_200 ):
    target = {p: E.ap(p) for p in prime_range(B) if N % p != _sage_const_0 }
    for f in NFs:
        ok = True
        for p,a in target.items():
            try:
                f_val = Integer(f[p])
                if f_val != a:
                    ok = False; break
            except Exception:
                ok = False; break
        if ok:
            return f
    return None

f = match_form_to_E(NFs, E)
if f is None:
    print("[03] Could not identify the newform for E; aborting.")
    sys.exit(_sage_const_0 )

primes = [p for p in prime_range(Lmax) if N % p != _sage_const_0 ]
features = []  # columns indexed by (l,m)
for l in primes:
    for m in range(_sage_const_1 , Mmax+_sage_const_1 ):
        features.append((l,m))

# feature vector for a form g: phi_{l,m}(g) = alpha^m + beta^m
C = ComplexField(_sage_const_100 )

def frob_eigs(a, l):
    D = C(a*a - _sage_const_4 *l)
    sD = D.sqrt()
    return ( (a + sD)/_sage_const_2 , (a - sD)/_sage_const_2  )

def feat_vec(g):
    vals = []
    for (l,m) in features:
        a = g[l]
        alpha, beta = frob_eigs(a, l)
        vals.append((alpha**m + beta**m).real())  # use real part
    return vector(RDF, [RR(v) for v in vals])

vf = feat_vec(f)
Gs = [g for g in NFs if g != f]
print(f"Found {len(Gs)} other forms")

# Store feature vectors for all forms
all_feature_vecs = {}
all_feature_vecs['f'] = [float(x) for x in vf]
for i, g in enumerate(Gs):
    all_feature_vecs[f'g_{i}'] = [float(x) for x in feat_vec(g)]

# Store P(g) values
P_values = {}

if len(Gs) == _sage_const_0 :
    print("[03] Only one newform at this level; trivial separator P(T)=1")
    # Save results
    results = {
        'curve': curve,
        'parameters': {
            'Lmax': int(Lmax),
            'Mmax': int(Mmax)
        },
        'curve_data': {
            'conductor': int(N),
            'num_newforms': _sage_const_1 
        },
        'features': [(int(l), int(m)) for l, m in features],
        'polynomial_coefficients': [float(_sage_const_1 /sum(vf**_sage_const_2 )) for _ in vf],  # trivial case
        'feature_vectors': all_feature_vecs,
        'P_values': {'f': _sage_const_1p0 },
        'spectral_gap': _sage_const_1p0 
    }
    filename = save_json_results('gap_poly', results, curve)
    print(f"[03] Saved results to {filename}")
    sys.exit(_sage_const_0 )

M = matrix(RDF, [feat_vec(g) for g in Gs])  # rows = other forms

# If only one other form, use simpler approach
if len(Gs) == _sage_const_1 :
    g = Gs[_sage_const_0 ]
    vg = feat_vec(g)
    # Find c such that vf*c = 1 and minimize |vg*c|
    c = vf / (vf * vf)
    val_f = _sage_const_1p0 
    val_g = abs(vg * c)
    delta = _sage_const_1  - val_g
    
    P_values['f'] = val_f
    P_values['g_0'] = float(val_g)
    poly_coeffs = [float(x) for x in c]
    
    print(f"[03] Hecke separator with {len(features)} features, normalized P(f)=1")
    print(f"     |P(g)| = {val_g:.6f}  =>  spectral gap delta ≈ {delta:.6f}")

else:
    # Constrained least squares: minimize ||M c||^2 s.t. vf * c = 1
    A = M
    B = matrix(RDF, _sage_const_1 , M.ncols(), vf)
    Z = block_matrix([[A.T*A, B.T],[B, matrix(RDF,_sage_const_1 ,_sage_const_1 ,[_sage_const_0 ])]])
    rhs = vector(RDF, [_sage_const_0 ]*M.ncols() + [_sage_const_1 ])
    sol = Z.solve_right(rhs)
    c = sol[:M.ncols()]
    
    vals_all = [ (feat_vec(g) * c) for g in NFs ]
    val_f = (vf * c)
    vals_others = [abs(v) for g,v in zip(NFs, vals_all) if g != f]
    
    P_values['f'] = float(val_f)
    for i, (g, v) in enumerate([(g, v) for g, v in zip(NFs, vals_all) if g != f]):
        P_values[f'g_{i}'] = float(abs(v))
    
    poly_coeffs = [float(x) for x in c]
    
    delta = _sage_const_1  - max(vals_others) if len(vals_others)>_sage_const_0  else _sage_const_1 
    print(f"[03] Hecke separator with {len(features)} features, normalized P(f)=1")
    print(f"     max_{g!=f} |P(g)| = {_sage_const_1 -delta:.6f}  =>  spectral gap delta ≈ {delta:.6f}")

# Save all results
results = {
    'curve': curve,
    'parameters': {
        'Lmax': int(Lmax),
        'Mmax': int(Mmax)
    },
    'curve_data': {
        'conductor': int(N),
        'num_newforms': len(NFs)
    },
    'features': [(int(l), int(m)) for l, m in features],
    'polynomial_coefficients': poly_coeffs,
    'feature_vectors': all_feature_vecs,
    'P_values': P_values,
    'spectral_gap': float(delta)
}

filename = save_json_results('gap_poly', results, curve)
print(f"[03] Saved results to {filename}")

