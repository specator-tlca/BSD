

# This file was *autogenerated* from the file src/05_kappa_leading_coeff.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)#!/usr/bin/env sage
# Purpose: assemble BSD leading-coefficient block (Reg, Ω, ∏c_p, torsion); compare to L^{(r)}(1)/r!.
# Usage:   sage src/05_kappa_leading_coeff.sage <curve>
# Prints:  r, Reg, Ω, ∏c_p, |E(Q)_tors|, numeric L^{(r)}(1)/r! if available, and classical block.
# Output:  data/bsd_components_*.json with all BSD components
# Note:    κ is a finite renorm normalization; rank identity does not depend on κ.

import sys
from sage.all import *

# Import save utils
sys.path.append('src')
from save_utils import save_json_results

curve = sys.argv[_sage_const_1 ] if len(sys.argv) > _sage_const_1  else '37a1'
E = EllipticCurve(curve)

r = E.rank()
Reg = E.regulator()
Omega = E.period_lattice().real_period()
cp = prod(E.tamagawa_numbers())
T = E.torsion_subgroup().order()

# Get individual Tamagawa numbers
tamagawa_dict = {}
bad_primes = E.conductor().support()
for p in bad_primes:
    tamagawa_dict[str(p)] = int(E.tamagawa_number(p))

L = E.lseries().dokchitser()
# Extract L^{(r)}(E,1)/r! numerically (Sage provides derivatives via Dokchitser)
Lr = None
L_derivatives = []
try:
    if r == _sage_const_0 :
        Lr = L(_sage_const_1 )
        L_derivatives.append({'order': _sage_const_0 , 'value': float(Lr)})
    else:
        # use Taylor expansion to order r and read the coefficient
        ts = L.taylor_series(_sage_const_1 , r+_sage_const_1 )
        for k in range(r+_sage_const_1 ):
            L_derivatives.append({'order': k, 'value': float(ts[k])})
        Lr = ts[r]
except Exception as e:
    print(f"Warning: Could not compute L-derivative: {e}")
    Lr = None

print(f"[05] Curve {curve}")
print(f"     r={r}, Reg={Reg}, Omega={Omega}, prod c_p={cp}, |E(Q)_tors|={T}")

BSD_block = None
if Lr is not None:
    print(f"     L^{({r})}(E,1)/{r}! ≈ {Lr}")
    BSD_block = Reg * (Omega * cp * _sage_const_1 ) / (T*T)
    print(f"     BSD classical block (sans |Sha|, sans kappa) ≈ {BSD_block}")
    print("     (kappa is a normalization from the renorm system; set kappa=1 for canonical NT.)")
else:
    print("     Could not compute L-derivative numerically in this environment.")

# Get generators if available
generators = []
try:
    gens = E.gens()
    for g in gens:
        generators.append({
            'point': str(g),
            'height': float(g.height())
        })
except:
    print("     Could not compute generators")

# Save all BSD components
results = {
    'curve': curve,
    'curve_data': {
        'conductor': int(E.conductor()),
        'rank': int(r),
        'torsion_order': int(T),
        'torsion_structure': [int(x) for x in E.torsion_subgroup().invariants()]
    },
    'bsd_components': {
        'rank': int(r),
        'regulator': float(Reg) if Reg else None,
        'real_period': float(Omega),
        'tamagawa_product': int(cp),
        'tamagawa_numbers': tamagawa_dict,
        'torsion_order': int(T),
        'generators': generators
    },
    'L_series': {
        'L_derivatives': L_derivatives,
        'L_r_over_r_factorial': float(Lr) if Lr else None
    },
    'bsd_block': {
        'value': float(BSD_block) if BSD_block else None,
        'formula': 'Reg * Omega * prod(c_p) / |E(Q)_tors|^2',
        'note': 'Missing factors: |Sha| and kappa (isogeny-invariant normalization)'
    }
}

filename = save_json_results('bsd_components', results, curve)
print(f"[05] Saved results to {filename}")

